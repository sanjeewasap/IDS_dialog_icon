import { ChangeDetectionStrategy, Component, Output, EventEmitter, HostBinding, Input, Optional } from '@angular/core';
import { ArgumentHelper } from '../utils/argument.helper';
import * as i0 from "@angular/core";
import * as i1 from "./soho-tree.service";
/**
 * Angular Wrapper for the Soho Tree Component.
 *
 * This component searches for an unordered list (ul) with the attribute
 * 'soho-tree' in the parent's DOM tree, initialising those found with
 * the SoHo tree control.
 *
 * The data is provided either by the content (li elements), a dataset
 * input or an implementation of the TreeService interface, by specifying
 * an implementation on the hosting component, e.g.
 *
 * providers: [ provide: TreeService, useClass: TreeDemoService} ]
 *
 * @todo Content based version does not work due to lack of TreeNode.
 * @todo Complete interface definition
 */
export class SohoTreeComponent {
    // -------------------------------------------
    // Soho Tree Types
    // -------------------------------------------
    // "auto" where nodes are obtained from an injected service (if defined) or via the Inputs if not.
    static { this.AUTO = 'auto'; }
    // 'content-only' where elements are used.
    static { this.CONTENT_ONLY = 'content-only'; }
    // -------------------------------------------
    // Component Inputs
    // -------------------------------------------
    // The array of root tree nodes to display.
    set dataset(dataset) {
        // @todo this is not fully working as the tree control does not
        // replace the contents but looks to merge it.
        this.options.dataset = dataset;
        if (this.tree) {
            this.tree?.loadData(dataset);
        }
    }
    get dataset() {
        // If the Soho control has been created, then the dataset
        // in the settings object will contain the rows currently
        // on display.
        if (this.tree) {
            return this.tree.settings.dataset;
        }
        // ... we've been called before the component has completed
        // initialisation, so no data has been set (or potentially
        // retrieved from a service), so the only option is the
        // Input dataset, which may be undefined.
        return this.options.dataset || [];
    }
    /** Defines the source type of the tree. */
    // eslint-disable-next-line @angular-eslint/no-input-rename
    set sohoTree(treeType) {
        this.treeType = treeType ? treeType : SohoTreeComponent.AUTO;
    }
    /** Is the tree selectable? */
    set selectable(selectable) {
        this.options.selectable = selectable;
        if (this.tree) {
            this.tree.settings.selectable = selectable;
            // @todo - make tree updatable when settings change,
            // this.tree?.updated();
        }
    }
    get selectable() {
        if (this.tree) {
            return this.tree.settings.selectable;
        }
        return this.options.selectable;
    }
    /** Show/hide selection checkboxe */
    set hideCheckboxes(hideCheckboxes) {
        this.options.hideCheckboxes = hideCheckboxes;
        if (this.tree) {
            this.tree.settings.hideCheckboxes = hideCheckboxes;
        }
    }
    set menuId(menuId) {
        this.options.menuId = menuId;
        if (this.tree) {
            this.tree.settings.menuId = menuId;
        }
    }
    /** Set the source field, when not using a service or pre-defined data. */
    set source(value) {
        this.options.source = value;
        if (this.tree) {
            this.tree.settings.source = value;
            // @todo - make tree updatable when settings change,
            // this.tree?.updated();
        }
    }
    /** Show icon on node opened */
    set folderIconOpen(folderIconOpen) {
        this.options.folderIconOpen = folderIconOpen;
        if (this.tree) {
            this.tree.settings.folderIconOpen = folderIconOpen;
        }
    }
    /** Show icon on node closed */
    set folderIconClosed(folderIconClosed) {
        this.options.folderIconClosed = folderIconClosed;
        if (this.tree) {
            this.tree.settings.folderIconClosed = folderIconClosed;
        }
    }
    /**
     * Constructor.
     *
     * @param elementRef - the element matching this directive.
     * @param treeService - service for obtaining data (optional)
     */
    constructor(elementRef, treeService) {
        this.elementRef = elementRef;
        this.treeService = treeService;
        // -------------------------------------------
        // Component Output
        // -------------------------------------------
        /**
         * This event is fired when a node is expanded, the SohoTreeNode
         * expanded is passed in the argument passed to the handler.
         */
        this.expanded = new EventEmitter();
        /**
         * This event is fired when a node is collapsed, the SohoTreeNode
         * collapsed is passed in the argument passed to the handler.
         */
        this.collapsed = new EventEmitter();
        /**
         * This event is fired when a node is selected, the SohoTreeNode
         * selected is passed in the argument passed to the handler.
         * */
        this.selected = new EventEmitter();
        /**
         * This event is fired when right clicking a node.
         * */
        // @todo fix the use of this native attribute
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.contextmenu = new EventEmitter();
        /**
         * This event is fired when a node is unselected, the SohoTreeNode
         * unselected is passed in the argument passed to the handler.
         * */
        this.unselected = new EventEmitter();
        this.sortstart = new EventEmitter();
        this.sortend = new EventEmitter();
        /**
         * This event is fired when context menu is selected, the SohoTreeNode
         * selected is passed in the argument passed to the handler.
         * */
        this.menuselect = new EventEmitter();
        /**
         * This event is fired on context menu opening, the SohoTreeNode
         * selected is passed in the argument passed to the handler.
         * */
        this.menuopen = new EventEmitter();
        // -------------------------------------------
        // Host Bindings
        // -------------------------------------------
        // Set the enable / disabled class (not working)
        this.isDisabled = false;
        // Set the appropriate SoHo class for a tree.
        this.treeClass = true;
        // Set the role.
        this.treeRole = 'tree';
        /** An internal options object that gets updated by using the component's Inputs(). */
        this.options = {};
    }
    // -------------------------------------------
    // Public API
    // -------------------------------------------
    /**
     * Resets the data display to the default provided by the service,
     * that is by calling getRootNodes.
     *
     * The alternative is to set the dataset property, which
     * has the same affect but allows the client to specify
     * the nodes.
     *
     * This method is only applicable when the service is defined,
     * but will not fail if one is not set.
     */
    reset() {
        if (this.treeType !== SohoTreeComponent.CONTENT_ONLY && this.treeService) {
            this.treeService.getRootTreeNodes()
                .subscribe((dataset) => this.dataset = dataset);
        }
    }
    /** Enable the tree */
    enable() {
        this.isDisabled = false;
        if (this.tree) {
            this.tree?.enable();
        }
    }
    /** Disables the tree from reacting to events. */
    disable() {
        this.isDisabled = true;
        if (this.tree) {
            this.tree?.disable();
        }
    }
    setFocus(node) {
        ArgumentHelper.checkNotNull('node', node);
        this.tree?.setFocus(node);
    }
    disableNode(node) {
        ArgumentHelper.checkNotNull('node', node);
        node.disabled = true;
        this.tree?.updateNode(node);
    }
    enableNode(node) {
        ArgumentHelper.checkNotNull('node', node);
        node.disabled = false;
        this.tree?.updateNode(node);
    }
    /**
     * Updates the note with the information in the given SohoTreeNode.
     *
     * @parm node the tree node; must not be null.
     */
    updateNode(node) {
        ArgumentHelper.checkNotNull('node', node);
        this.tree?.updateNode(node);
    }
    /**
     * Expands all the loaded tree nodes.
     *
     * Note: this does not load additional nodes.
     */
    expandAll() {
        if (this.tree) {
            this.tree?.expandAll();
        }
    }
    /**
     * Collapse all the tree nodes.
     */
    collapseAll() {
        if (this.tree) {
            this.tree?.collapseAll();
        }
    }
    /**
     * Remove the given node.
     */
    removeNode(node) {
        if (this.tree) {
            this.tree?.removeNode(node);
        }
    }
    /**
     * Preserves all nodes' enablement states in the Tree component
     */
    preserveEnablementState() {
        if (this.tree) {
            return this.tree?.preserveEnablementState();
        }
    }
    /**
     * Restores all nodes' original enablement states in the Tree component
     */
    restoreEnablementState() {
        if (this.tree) {
            this.tree?.restoreEnablementState();
        }
    }
    /**
     * Set the selected note based in the id of the node.  If the node
     * does not exist an exception is thrown.
     */
    selectNode(id, focus = true) {
        ArgumentHelper.checkNotEmpty('id', id);
        const treeNode = this.tree?.findById(id);
        if (treeNode && treeNode.node) {
            this.tree?.selectNode(treeNode.node, focus);
        }
        else {
            throw Error(`Node ${id} does not exist`);
        }
    }
    /**
     * Set the selected note based in the id of the node.  If the node
     * does not exist an exception is thrown.
     */
    unSelectedNode(id, focus = false) {
        ArgumentHelper.checkNotEmpty('id', id);
        const treeNode = this.tree.findById(id);
        if (treeNode && treeNode.node) {
            this.tree.unSelectedNode(treeNode.node, focus);
        }
        else {
            throw Error(`Node ${id} does not exist`);
        }
    }
    /**
     * Returns a list of selected tree nodes, or an
     * empty array if the tree has not been initialised
     * yet.
     */
    getSelectedNodes() {
        const result = [];
        if (this.tree) {
            // It would be good if the tree widget had a method that returned
            // tree nodes rather then an intermediate wrapper, but to clean up
            // the api we dispose of the extra information here.
            this.tree?.getSelectedNodes().forEach((n) => {
                result.push(n.data);
            });
        }
        return result;
    }
    /**
     * Adds a node to the tree.
     */
    addNode(treeNode, location = 'bottom', isBeforeOrAfter = '') {
        ArgumentHelper.checkNotNull('treeNode', treeNode);
        this.tree?.addNode(treeNode, location, isBeforeOrAfter);
    }
    /**
     * Find the tree node for the given identifier (id).
     */
    findById(id) {
        ArgumentHelper.checkNotEmpty('id', id);
        return this.tree.findById(id);
    }
    /**
     * Toggles open/closed state of the given tree node.
     */
    toggleNode(node) {
        ArgumentHelper.checkNotNull('node', node);
        ArgumentHelper.checkNotNull('node.node', node.node);
        this.tree?.toggleNode(node.node);
    }
    // -------------------------------------------
    // Event Handlers
    // -------------------------------------------
    /**
     * Handle a request to load the children of the specified node.
     *
     * event - the tree event used to determine which node to load
     * response - function used to return the children
     */
    onDataRequest(event, response) {
        const node = event.data;
        this.treeService.getTreeNodes(node)
            .subscribe((children) => {
            response(children);
        });
    }
    // ------------------------------------------
    // Lifecycle Events
    // ------------------------------------------
    ngOnInit() {
    }
    ngAfterViewInit() {
        // Wrap the "unordered list" element in a jQuery selector.
        this.jQueryElement = jQuery(this.elementRef.nativeElement);
        // Ensure the source is set when a service is defined.
        if (!this.options.dataset && !this.options.source && this.treeService) {
            this.options.source =
                (args, response) => this.onDataRequest(args, response);
        }
        // Initialise the Soho control.
        this.jQueryElement.tree(this.options);
        // Once the control is initialised, extract the control
        // plug-in from the element.  The element name is
        // defined by the plug-in, but in this case it is 'tree'.
        this.tree = this.jQueryElement.data('tree');
        // Preload from the service if specified (unless data already provided).
        if (this.treeType !== SohoTreeComponent.CONTENT_ONLY && !this.options.dataset && this.treeService) {
            // ... bootstrap the root nodes ...
            this.treeService.getRootTreeNodes()
                .subscribe((dataset) => this.dataset = dataset);
        }
        // Initialize any event handlers.
        this.jQueryElement
            .on('contextmenu', (_e, args) => this.contextmenu?.next(args))
            .on('selected', (_e, args) => this.selected.next(args))
            .on('unselected', (_e, args) => this.unselected.next(args))
            .on('expanded', (_e, args) => this.expanded.next(args))
            .on('collapsed', (_e, args) => this.collapsed.next(args))
            .on('sortstart', (_e, args) => this.sortstart.next(args))
            .on('sortend', (_e, args) => this.sortend.next(args))
            .on('menuselect', (_e, args) => this.menuselect.next(args))
            .on('menuopen', (_e, args) => this.menuopen.next(args));
    }
    ngOnDestroy() {
        if (this.tree) {
            this.tree?.destroy();
            this.tree = null;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.4", ngImport: i0, type: SohoTreeComponent, deps: [{ token: i0.ElementRef }, { token: i1.SohoTreeService, optional: true }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.4", type: SohoTreeComponent, selector: "ul[soho-tree]", inputs: { dataset: "dataset", sohoTree: ["soho-tree", "sohoTree"], selectable: "selectable", hideCheckboxes: "hideCheckboxes", menuId: "menuId", source: "source", folderIconOpen: "folderIconOpen", folderIconClosed: "folderIconClosed" }, outputs: { expanded: "expanded", collapsed: "collapsed", selected: "selected", contextmenu: "contextmenu", unselected: "unselected", sortstart: "sortstart", sortend: "sortend", menuselect: "menuselect", menuopen: "menuopen" }, host: { properties: { "class.is-disabled": "this.isDisabled", "class.tree": "this.treeClass", "attr.role": "this.treeRole" } }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.4", ngImport: i0, type: SohoTreeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ul[soho-tree]',
                    template: '<ng-content></ng-content>',
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.SohoTreeService, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { dataset: [{
                type: Input
            }], sohoTree: [{
                type: Input,
                args: ['soho-tree']
            }], selectable: [{
                type: Input
            }], hideCheckboxes: [{
                type: Input
            }], menuId: [{
                type: Input
            }], source: [{
                type: Input
            }], folderIconOpen: [{
                type: Input
            }], folderIconClosed: [{
                type: Input
            }], expanded: [{
                type: Output
            }], collapsed: [{
                type: Output
            }], selected: [{
                type: Output
            }], contextmenu: [{
                type: Output
            }], unselected: [{
                type: Output
            }], sortstart: [{
                type: Output
            }], sortend: [{
                type: Output
            }], menuselect: [{
                type: Output
            }], menuopen: [{
                type: Output
            }], isDisabled: [{
                type: HostBinding,
                args: ['class.is-disabled']
            }], treeClass: [{
                type: HostBinding,
                args: ['class.tree']
            }], treeRole: [{
                type: HostBinding,
                args: ['attr.role']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29oby10cmVlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lkcy1lbnRlcnByaXNlLW5nL3NyYy9saWIvdHJlZS9zb2hvLXRyZWUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUVULE1BQU0sRUFDTixZQUFZLEVBQ1osV0FBVyxFQUNYLEtBQUssRUFDTCxRQUFRLEVBR1QsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBCQUEwQixDQUFDOzs7QUFTMUQ7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBTUgsTUFBTSxPQUFPLGlCQUFpQjtJQUU1Qiw4Q0FBOEM7SUFDOUMsa0JBQWtCO0lBQ2xCLDhDQUE4QztJQUU5QyxrR0FBa0c7YUFDcEYsU0FBSSxHQUFpQixNQUFNLENBQUM7SUFFMUMsMENBQTBDO2FBQzVCLGlCQUFZLEdBQWlCLGNBQWMsQ0FBQztJQUUxRCw4Q0FBOEM7SUFDOUMsbUJBQW1CO0lBQ25CLDhDQUE4QztJQUU5QywyQ0FBMkM7SUFDM0MsSUFBYSxPQUFPLENBQUMsT0FBbUM7UUFDdEQsK0RBQStEO1FBQy9ELDhDQUE4QztRQUM5QyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDL0IsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2IsSUFBSSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUUsT0FBZSxDQUFDLENBQUM7U0FDdkM7SUFDSCxDQUFDO0lBRUQsSUFBSSxPQUFPO1FBQ1QseURBQXlEO1FBQ3pELHlEQUF5RDtRQUN6RCxjQUFjO1FBQ2QsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2IsT0FBUSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQWdCLENBQUMsT0FBTyxDQUFDO1NBQzVDO1FBRUQsMkRBQTJEO1FBQzNELDBEQUEwRDtRQUMxRCx1REFBdUQ7UUFDdkQseUNBQXlDO1FBQ3pDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDO0lBQ3BDLENBQUM7SUFFRCwyQ0FBMkM7SUFDM0MsMkRBQTJEO0lBQzNELElBQXdCLFFBQVEsQ0FBQyxRQUFzQjtRQUNyRCxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUM7SUFDL0QsQ0FBQztJQUVELDhCQUE4QjtJQUM5QixJQUFhLFVBQVUsQ0FBQyxVQUEwQztRQUNoRSxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7UUFDckMsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1osSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFnQixDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7WUFDcEQsb0RBQW9EO1lBQ3BELHdCQUF3QjtTQUN6QjtJQUNILENBQUM7SUFDRCxJQUFJLFVBQVU7UUFDWixJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDYixPQUFRLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBZ0IsQ0FBQyxVQUFVLENBQUM7U0FDL0M7UUFFRCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDO0lBQ2pDLENBQUM7SUFFRCxvQ0FBb0M7SUFDcEMsSUFBYSxjQUFjLENBQUMsY0FBbUM7UUFDN0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEdBQUcsY0FBYyxDQUFDO1FBQzdDLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtZQUNaLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBZ0IsQ0FBQyxjQUFjLEdBQUcsY0FBYyxDQUFDO1NBQzdEO0lBQ0gsQ0FBQztJQUVELElBQWEsTUFBTSxDQUFDLE1BQTBCO1FBQzVDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUM3QixJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDWixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQWdCLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztTQUM3QztJQUNILENBQUM7SUFFRCwwRUFBMEU7SUFDMUUsSUFBYSxNQUFNLENBQUMsS0FBNkI7UUFDL0MsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQzVCLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtZQUNaLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBZ0IsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1lBQzNDLG9EQUFvRDtZQUNwRCx3QkFBd0I7U0FDekI7SUFDSCxDQUFDO0lBRUQsK0JBQStCO0lBQy9CLElBQWEsY0FBYyxDQUFDLGNBQXNCO1FBQ2hELElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxHQUFHLGNBQWMsQ0FBQztRQUM3QyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDWixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQWdCLENBQUMsY0FBYyxHQUFHLGNBQWMsQ0FBQztTQUM3RDtJQUNILENBQUM7SUFFRCwrQkFBK0I7SUFDL0IsSUFBYSxnQkFBZ0IsQ0FBQyxnQkFBd0I7UUFDcEQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztRQUNqRCxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDWixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQWdCLENBQUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUM7U0FDakU7SUFDSCxDQUFDO0lBa0ZEOzs7OztPQUtHO0lBQ0gsWUFDVSxVQUFzQixFQUNWLFdBQTRCO1FBRHhDLGVBQVUsR0FBVixVQUFVLENBQVk7UUFDVixnQkFBVyxHQUFYLFdBQVcsQ0FBaUI7UUF4RmxELDhDQUE4QztRQUM5QyxtQkFBbUI7UUFDbkIsOENBQThDO1FBRTlDOzs7V0FHRztRQUNPLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBaUIsQ0FBQztRQUV2RDs7O1dBR0c7UUFDTyxjQUFTLEdBQUcsSUFBSSxZQUFZLEVBQWlCLENBQUM7UUFFeEQ7OzthQUdLO1FBQ0ssYUFBUSxHQUFHLElBQUksWUFBWSxFQUFpQixDQUFDO1FBRXZEOzthQUVLO1FBQ0wsNkNBQTZDO1FBQzdDLDREQUE0RDtRQUNsRCxnQkFBVyxHQUFHLElBQUksWUFBWSxFQUFpQixDQUFDO1FBRTFEOzs7YUFHSztRQUNLLGVBQVUsR0FBRyxJQUFJLFlBQVksRUFBaUIsQ0FBQztRQUUvQyxjQUFTLEdBQUcsSUFBSSxZQUFZLEVBQWlCLENBQUM7UUFFOUMsWUFBTyxHQUFHLElBQUksWUFBWSxFQUFpQixDQUFDO1FBRXREOzs7YUFHSztRQUNLLGVBQVUsR0FBRyxJQUFJLFlBQVksRUFBaUIsQ0FBQztRQUV6RDs7O2FBR0s7UUFDSyxhQUFRLEdBQUcsSUFBSSxZQUFZLEVBQWlCLENBQUM7UUFFdkQsOENBQThDO1FBQzlDLGdCQUFnQjtRQUNoQiw4Q0FBOEM7UUFFOUMsZ0RBQWdEO1FBQ2QsZUFBVSxHQUFHLEtBQUssQ0FBQztRQUVyRCw2Q0FBNkM7UUFDbEIsY0FBUyxHQUFHLElBQUksQ0FBQztRQUU1QyxnQkFBZ0I7UUFDVSxhQUFRLEdBQUcsTUFBTSxDQUFDO1FBZTVDLHNGQUFzRjtRQUN0RixZQUFPLEdBQW9CLEVBQUUsQ0FBQztJQVc5QixDQUFDO0lBRUQsOENBQThDO0lBQzlDLGFBQWE7SUFDYiw4Q0FBOEM7SUFFOUM7Ozs7Ozs7Ozs7T0FVRztJQUNJLEtBQUs7UUFDVixJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssaUJBQWlCLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDeEUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsRUFBRTtpQkFDaEMsU0FBUyxDQUFDLENBQUMsT0FBdUIsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsQ0FBQztTQUNuRTtJQUNILENBQUM7SUFFRCxzQkFBc0I7SUFDZixNQUFNO1FBQ1gsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7UUFDeEIsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2IsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQztTQUNyQjtJQUNILENBQUM7SUFFRCxpREFBaUQ7SUFDMUMsT0FBTztRQUNaLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO1FBQ3ZCLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtZQUNiLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLENBQUM7U0FDdEI7SUFDSCxDQUFDO0lBRU0sUUFBUSxDQUFDLElBQWtCO1FBQ2hDLGNBQWMsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRTFDLElBQUksQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzVCLENBQUM7SUFFTSxXQUFXLENBQUMsSUFBa0I7UUFDbkMsY0FBYyxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFMUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDckIsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVNLFVBQVUsQ0FBQyxJQUFrQjtRQUNsQyxjQUFjLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUUxQyxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztRQUN0QixJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLFVBQVUsQ0FBQyxJQUFrQjtRQUNsQyxjQUFjLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUUxQyxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLFNBQVM7UUFDZCxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDYixJQUFJLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxDQUFDO1NBQ3hCO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ksV0FBVztRQUNoQixJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDYixJQUFJLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxDQUFDO1NBQzFCO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ksVUFBVSxDQUFDLElBQWtCO1FBQ2xDLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtZQUNiLElBQUksQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzdCO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ksdUJBQXVCO1FBQzVCLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtZQUNiLE9BQU8sSUFBSSxDQUFDLElBQUksRUFBRSx1QkFBdUIsRUFBRSxDQUFDO1NBQzdDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ksc0JBQXNCO1FBQzNCLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtZQUNiLElBQUksQ0FBQyxJQUFJLEVBQUUsc0JBQXNCLEVBQUUsQ0FBQztTQUNyQztJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSSxVQUFVLENBQUMsRUFBVSxFQUFFLEtBQUssR0FBRyxJQUFJO1FBQ3hDLGNBQWMsQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRXZDLE1BQU0sUUFBUSxHQUE2QixJQUFJLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNuRSxJQUFJLFFBQVEsSUFBSSxRQUFRLENBQUMsSUFBSSxFQUFFO1lBQzdCLElBQUksQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDN0M7YUFBTTtZQUNMLE1BQU0sS0FBSyxDQUFDLFFBQVEsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1NBQzFDO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNJLGNBQWMsQ0FBQyxFQUFVLEVBQUUsS0FBSyxHQUFHLEtBQUs7UUFDN0MsY0FBYyxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFdkMsTUFBTSxRQUFRLEdBQWtCLElBQUksQ0FBQyxJQUFZLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQy9ELElBQUksUUFBUSxJQUFJLFFBQVEsQ0FBQyxJQUFJLEVBQUU7WUFDNUIsSUFBSSxDQUFDLElBQVksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztTQUN6RDthQUFNO1lBQ0wsTUFBTSxLQUFLLENBQUMsUUFBUSxFQUFFLGlCQUFpQixDQUFDLENBQUM7U0FDMUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLGdCQUFnQjtRQUNyQixNQUFNLE1BQU0sR0FBbUIsRUFBRSxDQUFDO1FBQ2xDLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtZQUViLGlFQUFpRTtZQUNqRSxrRUFBa0U7WUFDbEUsb0RBQW9EO1lBQ3BELElBQUksQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsQ0FBQyxPQUFPLENBQ25DLENBQUMsQ0FBQyxFQUFFLEVBQUU7Z0JBQ0osTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdEIsQ0FBQyxDQUNGLENBQUM7U0FDSDtRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7T0FFRztJQUNJLE9BQU8sQ0FBQyxRQUFzQixFQUFFLFdBQWdCLFFBQVEsRUFBRSxlQUFlLEdBQUcsRUFBRTtRQUNuRixjQUFjLENBQUMsWUFBWSxDQUFDLFVBQVUsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUVsRCxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLGVBQWUsQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFFRDs7T0FFRztJQUNJLFFBQVEsQ0FBQyxFQUFVO1FBQ3hCLGNBQWMsQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRXZDLE9BQVEsSUFBSSxDQUFDLElBQVksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksVUFBVSxDQUFDLElBQWtCO1FBQ2xDLGNBQWMsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVwRCxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBRSxJQUFJLENBQUMsSUFBWSxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVELDhDQUE4QztJQUM5QyxpQkFBaUI7SUFDakIsOENBQThDO0lBRTlDOzs7OztPQUtHO0lBQ0ssYUFBYSxDQUFDLEtBQW9CLEVBQUUsUUFBa0M7UUFDNUUsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQztRQUV4QixJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7YUFDaEMsU0FBUyxDQUFDLENBQUMsUUFBd0IsRUFBRSxFQUFFO1lBQ3RDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNyQixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRCw2Q0FBNkM7SUFDN0MsbUJBQW1CO0lBQ25CLDZDQUE2QztJQUU3QyxRQUFRO0lBQ1IsQ0FBQztJQUVELGVBQWU7UUFDYiwwREFBMEQ7UUFDMUQsSUFBSSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUUzRCxzREFBc0Q7UUFDdEQsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNyRSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU07Z0JBQ2pCLENBQUMsSUFBbUIsRUFBRSxRQUFrQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztTQUNuRztRQUVELCtCQUErQjtRQUMvQixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFdEMsdURBQXVEO1FBQ3ZELGlEQUFpRDtRQUNqRCx5REFBeUQ7UUFDekQsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUU1Qyx3RUFBd0U7UUFDeEUsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLGlCQUFpQixDQUFDLFlBQVksSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDakcsbUNBQW1DO1lBQ25DLElBQUksQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLEVBQUU7aUJBQ2hDLFNBQVMsQ0FBQyxDQUFDLE9BQXVCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLENBQUM7U0FDbkU7UUFFRCxpQ0FBaUM7UUFDakMsSUFBSSxDQUFDLGFBQWE7YUFDZixFQUFFLENBQUMsYUFBYSxFQUFFLENBQUMsRUFBeUIsRUFBRSxJQUFtQixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNuRyxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBeUIsRUFBRSxJQUFtQixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM1RixFQUFFLENBQUMsWUFBWSxFQUFFLENBQUMsRUFBeUIsRUFBRSxJQUFtQixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNoRyxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBeUIsRUFBRSxJQUFtQixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM1RixFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsRUFBeUIsRUFBRSxJQUFtQixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM5RixFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsRUFBeUIsRUFBRSxJQUFtQixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM5RixFQUFFLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBeUIsRUFBRSxJQUFtQixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUMxRixFQUFFLENBQUMsWUFBWSxFQUFFLENBQUMsRUFBZ0IsRUFBRSxJQUFtQixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN2RixFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBZ0IsRUFBRSxJQUFtQixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3pGLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2IsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQztZQUNyQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztTQUNsQjtJQUNILENBQUM7OEdBNWNVLGlCQUFpQjtrR0FBakIsaUJBQWlCLHFvQkFIbEIsMkJBQTJCOzsyRkFHMUIsaUJBQWlCO2tCQUw3QixTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxlQUFlO29CQUN6QixRQUFRLEVBQUUsMkJBQTJCO29CQUNyQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtpQkFDaEQ7OzBCQWtNSSxRQUFROzRDQWhMRSxPQUFPO3NCQUFuQixLQUFLO2dCQTBCa0IsUUFBUTtzQkFBL0IsS0FBSzt1QkFBQyxXQUFXO2dCQUtMLFVBQVU7c0JBQXRCLEtBQUs7Z0JBaUJPLGNBQWM7c0JBQTFCLEtBQUs7Z0JBT08sTUFBTTtzQkFBbEIsS0FBSztnQkFRTyxNQUFNO3NCQUFsQixLQUFLO2dCQVVPLGNBQWM7c0JBQTFCLEtBQUs7Z0JBUU8sZ0JBQWdCO3NCQUE1QixLQUFLO2dCQWVJLFFBQVE7c0JBQWpCLE1BQU07Z0JBTUcsU0FBUztzQkFBbEIsTUFBTTtnQkFNRyxRQUFRO3NCQUFqQixNQUFNO2dCQU9HLFdBQVc7c0JBQXBCLE1BQU07Z0JBTUcsVUFBVTtzQkFBbkIsTUFBTTtnQkFFRyxTQUFTO3NCQUFsQixNQUFNO2dCQUVHLE9BQU87c0JBQWhCLE1BQU07Z0JBTUcsVUFBVTtzQkFBbkIsTUFBTTtnQkFNRyxRQUFRO3NCQUFqQixNQUFNO2dCQU8yQixVQUFVO3NCQUEzQyxXQUFXO3VCQUFDLG1CQUFtQjtnQkFHTCxTQUFTO3NCQUFuQyxXQUFXO3VCQUFDLFlBQVk7Z0JBR0MsUUFBUTtzQkFBakMsV0FBVzt1QkFBQyxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgT3V0cHV0LFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RCaW5kaW5nLFxuICBJbnB1dCxcbiAgT3B0aW9uYWwsXG4gIE9uSW5pdCxcbiAgT25EZXN0cm95XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBBcmd1bWVudEhlbHBlciB9IGZyb20gJy4uL3V0aWxzL2FyZ3VtZW50LmhlbHBlcic7XG5cbmltcG9ydCB7IFNvaG9UcmVlU2VydmljZSB9IGZyb20gJy4vc29oby10cmVlLnNlcnZpY2UnO1xuXG4vKipcbiAqICBWYWxpZCBsaXN0IG9mIHRyZWUgdHlwZXMuXG4gKi9cbmV4cG9ydCB0eXBlIFNvaG9UcmVlVHlwZSA9ICdhdXRvJyB8ICdjb250ZW50LW9ubHknO1xuXG4vKipcbiAqIEFuZ3VsYXIgV3JhcHBlciBmb3IgdGhlIFNvaG8gVHJlZSBDb21wb25lbnQuXG4gKlxuICogVGhpcyBjb21wb25lbnQgc2VhcmNoZXMgZm9yIGFuIHVub3JkZXJlZCBsaXN0ICh1bCkgd2l0aCB0aGUgYXR0cmlidXRlXG4gKiAnc29oby10cmVlJyBpbiB0aGUgcGFyZW50J3MgRE9NIHRyZWUsIGluaXRpYWxpc2luZyB0aG9zZSBmb3VuZCB3aXRoXG4gKiB0aGUgU29IbyB0cmVlIGNvbnRyb2wuXG4gKlxuICogVGhlIGRhdGEgaXMgcHJvdmlkZWQgZWl0aGVyIGJ5IHRoZSBjb250ZW50IChsaSBlbGVtZW50cyksIGEgZGF0YXNldFxuICogaW5wdXQgb3IgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIFRyZWVTZXJ2aWNlIGludGVyZmFjZSwgYnkgc3BlY2lmeWluZ1xuICogYW4gaW1wbGVtZW50YXRpb24gb24gdGhlIGhvc3RpbmcgY29tcG9uZW50LCBlLmcuXG4gKlxuICogcHJvdmlkZXJzOiBbIHByb3ZpZGU6IFRyZWVTZXJ2aWNlLCB1c2VDbGFzczogVHJlZURlbW9TZXJ2aWNlfSBdXG4gKlxuICogQHRvZG8gQ29udGVudCBiYXNlZCB2ZXJzaW9uIGRvZXMgbm90IHdvcmsgZHVlIHRvIGxhY2sgb2YgVHJlZU5vZGUuXG4gKiBAdG9kbyBDb21wbGV0ZSBpbnRlcmZhY2UgZGVmaW5pdGlvblxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1bFtzb2hvLXRyZWVdJywgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBTb2hvVHJlZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFNvaG8gVHJlZSBUeXBlc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gXCJhdXRvXCIgd2hlcmUgbm9kZXMgYXJlIG9idGFpbmVkIGZyb20gYW4gaW5qZWN0ZWQgc2VydmljZSAoaWYgZGVmaW5lZCkgb3IgdmlhIHRoZSBJbnB1dHMgaWYgbm90LlxuICBwdWJsaWMgc3RhdGljIEFVVE86IFNvaG9UcmVlVHlwZSA9ICdhdXRvJztcblxuICAvLyAnY29udGVudC1vbmx5JyB3aGVyZSBlbGVtZW50cyBhcmUgdXNlZC5cbiAgcHVibGljIHN0YXRpYyBDT05URU5UX09OTFk6IFNvaG9UcmVlVHlwZSA9ICdjb250ZW50LW9ubHknO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQ29tcG9uZW50IElucHV0c1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGFycmF5IG9mIHJvb3QgdHJlZSBub2RlcyB0byBkaXNwbGF5LlxuICBASW5wdXQoKSBzZXQgZGF0YXNldChkYXRhc2V0OiBTb2hvVHJlZU5vZGVbXSB8IHVuZGVmaW5lZCkge1xuICAgIC8vIEB0b2RvIHRoaXMgaXMgbm90IGZ1bGx5IHdvcmtpbmcgYXMgdGhlIHRyZWUgY29udHJvbCBkb2VzIG5vdFxuICAgIC8vIHJlcGxhY2UgdGhlIGNvbnRlbnRzIGJ1dCBsb29rcyB0byBtZXJnZSBpdC5cbiAgICB0aGlzLm9wdGlvbnMuZGF0YXNldCA9IGRhdGFzZXQ7XG4gICAgaWYgKHRoaXMudHJlZSkge1xuICAgICAgdGhpcy50cmVlPy5sb2FkRGF0YSgoZGF0YXNldCBhcyBhbnkpKTtcbiAgICB9XG4gIH1cblxuICBnZXQgZGF0YXNldCgpOiBTb2hvVHJlZU5vZGVbXSB8IHVuZGVmaW5lZCB7XG4gICAgLy8gSWYgdGhlIFNvaG8gY29udHJvbCBoYXMgYmVlbiBjcmVhdGVkLCB0aGVuIHRoZSBkYXRhc2V0XG4gICAgLy8gaW4gdGhlIHNldHRpbmdzIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIHJvd3MgY3VycmVudGx5XG4gICAgLy8gb24gZGlzcGxheS5cbiAgICBpZiAodGhpcy50cmVlKSB7XG4gICAgICByZXR1cm4gKHRoaXMudHJlZS5zZXR0aW5ncyBhcyBhbnkpLmRhdGFzZXQ7XG4gICAgfVxuXG4gICAgLy8gLi4uIHdlJ3ZlIGJlZW4gY2FsbGVkIGJlZm9yZSB0aGUgY29tcG9uZW50IGhhcyBjb21wbGV0ZWRcbiAgICAvLyBpbml0aWFsaXNhdGlvbiwgc28gbm8gZGF0YSBoYXMgYmVlbiBzZXQgKG9yIHBvdGVudGlhbGx5XG4gICAgLy8gcmV0cmlldmVkIGZyb20gYSBzZXJ2aWNlKSwgc28gdGhlIG9ubHkgb3B0aW9uIGlzIHRoZVxuICAgIC8vIElucHV0IGRhdGFzZXQsIHdoaWNoIG1heSBiZSB1bmRlZmluZWQuXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5kYXRhc2V0IHx8IFtdO1xuICB9XG5cbiAgLyoqIERlZmluZXMgdGhlIHNvdXJjZSB0eXBlIG9mIHRoZSB0cmVlLiAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L25vLWlucHV0LXJlbmFtZVxuICBASW5wdXQoJ3NvaG8tdHJlZScpIHNldCBzb2hvVHJlZSh0cmVlVHlwZTogU29ob1RyZWVUeXBlKSB7XG4gICAgdGhpcy50cmVlVHlwZSA9IHRyZWVUeXBlID8gdHJlZVR5cGUgOiBTb2hvVHJlZUNvbXBvbmVudC5BVVRPO1xuICB9XG5cbiAgLyoqIElzIHRoZSB0cmVlIHNlbGVjdGFibGU/ICovXG4gIEBJbnB1dCgpIHNldCBzZWxlY3RhYmxlKHNlbGVjdGFibGU6IFNvaG9UcmVlU2VsZWN0YWJsZSB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMub3B0aW9ucy5zZWxlY3RhYmxlID0gc2VsZWN0YWJsZTtcbiAgICBpZiAodGhpcy50cmVlKSB7XG4gICAgICAodGhpcy50cmVlLnNldHRpbmdzIGFzIGFueSkuc2VsZWN0YWJsZSA9IHNlbGVjdGFibGU7XG4gICAgICAvLyBAdG9kbyAtIG1ha2UgdHJlZSB1cGRhdGFibGUgd2hlbiBzZXR0aW5ncyBjaGFuZ2UsXG4gICAgICAvLyB0aGlzLnRyZWU/LnVwZGF0ZWQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNlbGVjdGFibGUoKTogU29ob1RyZWVTZWxlY3RhYmxlIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodGhpcy50cmVlKSB7XG4gICAgICByZXR1cm4gKHRoaXMudHJlZS5zZXR0aW5ncyBhcyBhbnkpLnNlbGVjdGFibGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zZWxlY3RhYmxlO1xuICB9XG5cbiAgLyoqIFNob3cvaGlkZSBzZWxlY3Rpb24gY2hlY2tib3hlICovXG4gIEBJbnB1dCgpIHNldCBoaWRlQ2hlY2tib3hlcyhoaWRlQ2hlY2tib3hlczogYm9vbGVhbiB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMub3B0aW9ucy5oaWRlQ2hlY2tib3hlcyA9IGhpZGVDaGVja2JveGVzO1xuICAgIGlmICh0aGlzLnRyZWUpIHtcbiAgICAgICh0aGlzLnRyZWUuc2V0dGluZ3MgYXMgYW55KS5oaWRlQ2hlY2tib3hlcyA9IGhpZGVDaGVja2JveGVzO1xuICAgIH1cbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBtZW51SWQobWVudUlkOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLm9wdGlvbnMubWVudUlkID0gbWVudUlkO1xuICAgIGlmICh0aGlzLnRyZWUpIHtcbiAgICAgICh0aGlzLnRyZWUuc2V0dGluZ3MgYXMgYW55KS5tZW51SWQgPSBtZW51SWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqIFNldCB0aGUgc291cmNlIGZpZWxkLCB3aGVuIG5vdCB1c2luZyBhIHNlcnZpY2Ugb3IgcHJlLWRlZmluZWQgZGF0YS4gKi9cbiAgQElucHV0KCkgc2V0IHNvdXJjZSh2YWx1ZTogU29ob1RyZWVTb3VyY2VGdW5jdGlvbikge1xuICAgIHRoaXMub3B0aW9ucy5zb3VyY2UgPSB2YWx1ZTtcbiAgICBpZiAodGhpcy50cmVlKSB7XG4gICAgICAodGhpcy50cmVlLnNldHRpbmdzIGFzIGFueSkuc291cmNlID0gdmFsdWU7XG4gICAgICAvLyBAdG9kbyAtIG1ha2UgdHJlZSB1cGRhdGFibGUgd2hlbiBzZXR0aW5ncyBjaGFuZ2UsXG4gICAgICAvLyB0aGlzLnRyZWU/LnVwZGF0ZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKiogU2hvdyBpY29uIG9uIG5vZGUgb3BlbmVkICovXG4gIEBJbnB1dCgpIHNldCBmb2xkZXJJY29uT3Blbihmb2xkZXJJY29uT3Blbjogc3RyaW5nKSB7XG4gICAgdGhpcy5vcHRpb25zLmZvbGRlckljb25PcGVuID0gZm9sZGVySWNvbk9wZW47XG4gICAgaWYgKHRoaXMudHJlZSkge1xuICAgICAgKHRoaXMudHJlZS5zZXR0aW5ncyBhcyBhbnkpLmZvbGRlckljb25PcGVuID0gZm9sZGVySWNvbk9wZW47XG4gICAgfVxuICB9XG5cbiAgLyoqIFNob3cgaWNvbiBvbiBub2RlIGNsb3NlZCAqL1xuICBASW5wdXQoKSBzZXQgZm9sZGVySWNvbkNsb3NlZChmb2xkZXJJY29uQ2xvc2VkOiBzdHJpbmcpIHtcbiAgICB0aGlzLm9wdGlvbnMuZm9sZGVySWNvbkNsb3NlZCA9IGZvbGRlckljb25DbG9zZWQ7XG4gICAgaWYgKHRoaXMudHJlZSkge1xuICAgICAgKHRoaXMudHJlZS5zZXR0aW5ncyBhcyBhbnkpLmZvbGRlckljb25DbG9zZWQgPSBmb2xkZXJJY29uQ2xvc2VkO1xuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQ29tcG9uZW50IE91dHB1dFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIG5vZGUgaXMgZXhwYW5kZWQsIHRoZSBTb2hvVHJlZU5vZGVcbiAgICogZXhwYW5kZWQgaXMgcGFzc2VkIGluIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gdGhlIGhhbmRsZXIuXG4gICAqL1xuICBAT3V0cHV0KCkgZXhwYW5kZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFNvaG9UcmVlRXZlbnQ+KCk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIG5vZGUgaXMgY29sbGFwc2VkLCB0aGUgU29ob1RyZWVOb2RlXG4gICAqIGNvbGxhcHNlZCBpcyBwYXNzZWQgaW4gdGhlIGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgaGFuZGxlci5cbiAgICovXG4gIEBPdXRwdXQoKSBjb2xsYXBzZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFNvaG9UcmVlRXZlbnQ+KCk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIG5vZGUgaXMgc2VsZWN0ZWQsIHRoZSBTb2hvVHJlZU5vZGVcbiAgICogc2VsZWN0ZWQgaXMgcGFzc2VkIGluIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gdGhlIGhhbmRsZXIuXG4gICAqICovXG4gIEBPdXRwdXQoKSBzZWxlY3RlZCA9IG5ldyBFdmVudEVtaXR0ZXI8U29ob1RyZWVFdmVudD4oKTtcblxuICAvKipcbiAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHJpZ2h0IGNsaWNraW5nIGEgbm9kZS5cbiAgICogKi9cbiAgLy8gQHRvZG8gZml4IHRoZSB1c2Ugb2YgdGhpcyBuYXRpdmUgYXR0cmlidXRlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvbm8tb3V0cHV0LW5hdGl2ZVxuICBAT3V0cHV0KCkgY29udGV4dG1lbnUgPSBuZXcgRXZlbnRFbWl0dGVyPFNvaG9UcmVlRXZlbnQ+KCk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIG5vZGUgaXMgdW5zZWxlY3RlZCwgdGhlIFNvaG9UcmVlTm9kZVxuICAgKiB1bnNlbGVjdGVkIGlzIHBhc3NlZCBpbiB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBoYW5kbGVyLlxuICAgKiAqL1xuICBAT3V0cHV0KCkgdW5zZWxlY3RlZCA9IG5ldyBFdmVudEVtaXR0ZXI8U29ob1RyZWVFdmVudD4oKTtcblxuICBAT3V0cHV0KCkgc29ydHN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcjxTb2hvVHJlZUV2ZW50PigpO1xuXG4gIEBPdXRwdXQoKSBzb3J0ZW5kID0gbmV3IEV2ZW50RW1pdHRlcjxTb2hvVHJlZUV2ZW50PigpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gY29udGV4dCBtZW51IGlzIHNlbGVjdGVkLCB0aGUgU29ob1RyZWVOb2RlXG4gICAqIHNlbGVjdGVkIGlzIHBhc3NlZCBpbiB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBoYW5kbGVyLlxuICAgKiAqL1xuICBAT3V0cHV0KCkgbWVudXNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXI8U29ob1RyZWVFdmVudD4oKTtcblxuICAvKipcbiAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBjb250ZXh0IG1lbnUgb3BlbmluZywgdGhlIFNvaG9UcmVlTm9kZVxuICAgKiBzZWxlY3RlZCBpcyBwYXNzZWQgaW4gdGhlIGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgaGFuZGxlci5cbiAgICogKi9cbiAgQE91dHB1dCgpIG1lbnVvcGVuID0gbmV3IEV2ZW50RW1pdHRlcjxTb2hvVHJlZUV2ZW50PigpO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gSG9zdCBCaW5kaW5nc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gU2V0IHRoZSBlbmFibGUgLyBkaXNhYmxlZCBjbGFzcyAobm90IHdvcmtpbmcpXG4gIEBIb3N0QmluZGluZygnY2xhc3MuaXMtZGlzYWJsZWQnKSBpc0Rpc2FibGVkID0gZmFsc2U7XG5cbiAgLy8gU2V0IHRoZSBhcHByb3ByaWF0ZSBTb0hvIGNsYXNzIGZvciBhIHRyZWUuXG4gIEBIb3N0QmluZGluZygnY2xhc3MudHJlZScpIHRyZWVDbGFzcyA9IHRydWU7XG5cbiAgLy8gU2V0IHRoZSByb2xlLlxuICBASG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpIHRyZWVSb2xlID0gJ3RyZWUnO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUHJpdmF0ZSBNZW1iZXIgRGF0YVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgalF1ZXJ5IGNvbnRyb2wuICovXG4gIHByaXZhdGUgalF1ZXJ5RWxlbWVudD86IEpRdWVyeTtcblxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSBTb0hvIHRyZWUgY29udHJvbCBhcGkuICovXG4gIHByaXZhdGUgdHJlZT86IFNvaG9UcmVlU3RhdGljIHwgbnVsbDtcblxuICAvKiogVGhlIHRyZWUncyB0eXBlLiAqL1xuICBwcml2YXRlIHRyZWVUeXBlPzogU29ob1RyZWVUeXBlO1xuXG4gIC8qKiBBbiBpbnRlcm5hbCBvcHRpb25zIG9iamVjdCB0aGF0IGdldHMgdXBkYXRlZCBieSB1c2luZyB0aGUgY29tcG9uZW50J3MgSW5wdXRzKCkuICovXG4gIG9wdGlvbnM6IFNvaG9UcmVlT3B0aW9ucyA9IHt9O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnRSZWYgLSB0aGUgZWxlbWVudCBtYXRjaGluZyB0aGlzIGRpcmVjdGl2ZS5cbiAgICogQHBhcmFtIHRyZWVTZXJ2aWNlIC0gc2VydmljZSBmb3Igb2J0YWluaW5nIGRhdGEgKG9wdGlvbmFsKVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgdHJlZVNlcnZpY2U6IFNvaG9UcmVlU2VydmljZSkge1xuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQdWJsaWMgQVBJXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBkYXRhIGRpc3BsYXkgdG8gdGhlIGRlZmF1bHQgcHJvdmlkZWQgYnkgdGhlIHNlcnZpY2UsXG4gICAqIHRoYXQgaXMgYnkgY2FsbGluZyBnZXRSb290Tm9kZXMuXG4gICAqXG4gICAqIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byBzZXQgdGhlIGRhdGFzZXQgcHJvcGVydHksIHdoaWNoXG4gICAqIGhhcyB0aGUgc2FtZSBhZmZlY3QgYnV0IGFsbG93cyB0aGUgY2xpZW50IHRvIHNwZWNpZnlcbiAgICogdGhlIG5vZGVzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBvbmx5IGFwcGxpY2FibGUgd2hlbiB0aGUgc2VydmljZSBpcyBkZWZpbmVkLFxuICAgKiBidXQgd2lsbCBub3QgZmFpbCBpZiBvbmUgaXMgbm90IHNldC5cbiAgICovXG4gIHB1YmxpYyByZXNldCgpIHtcbiAgICBpZiAodGhpcy50cmVlVHlwZSAhPT0gU29ob1RyZWVDb21wb25lbnQuQ09OVEVOVF9PTkxZICYmIHRoaXMudHJlZVNlcnZpY2UpIHtcbiAgICAgIHRoaXMudHJlZVNlcnZpY2UuZ2V0Um9vdFRyZWVOb2RlcygpXG4gICAgICAgIC5zdWJzY3JpYmUoKGRhdGFzZXQ6IFNvaG9UcmVlTm9kZVtdKSA9PiB0aGlzLmRhdGFzZXQgPSBkYXRhc2V0KTtcbiAgICB9XG4gIH1cblxuICAvKiogRW5hYmxlIHRoZSB0cmVlICovXG4gIHB1YmxpYyBlbmFibGUoKTogdm9pZCB7XG4gICAgdGhpcy5pc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMudHJlZSkge1xuICAgICAgdGhpcy50cmVlPy5lbmFibGUoKTtcbiAgICB9XG4gIH1cblxuICAvKiogRGlzYWJsZXMgdGhlIHRyZWUgZnJvbSByZWFjdGluZyB0byBldmVudHMuICovXG4gIHB1YmxpYyBkaXNhYmxlKCk6IHZvaWQge1xuICAgIHRoaXMuaXNEaXNhYmxlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMudHJlZSkge1xuICAgICAgdGhpcy50cmVlPy5kaXNhYmxlKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldEZvY3VzKG5vZGU6IFNvaG9UcmVlTm9kZSkge1xuICAgIEFyZ3VtZW50SGVscGVyLmNoZWNrTm90TnVsbCgnbm9kZScsIG5vZGUpO1xuXG4gICAgdGhpcy50cmVlPy5zZXRGb2N1cyhub2RlKTtcbiAgfVxuXG4gIHB1YmxpYyBkaXNhYmxlTm9kZShub2RlOiBTb2hvVHJlZU5vZGUpIHtcbiAgICBBcmd1bWVudEhlbHBlci5jaGVja05vdE51bGwoJ25vZGUnLCBub2RlKTtcblxuICAgIG5vZGUuZGlzYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMudHJlZT8udXBkYXRlTm9kZShub2RlKTtcbiAgfVxuXG4gIHB1YmxpYyBlbmFibGVOb2RlKG5vZGU6IFNvaG9UcmVlTm9kZSk6IHZvaWQge1xuICAgIEFyZ3VtZW50SGVscGVyLmNoZWNrTm90TnVsbCgnbm9kZScsIG5vZGUpO1xuXG4gICAgbm9kZS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMudHJlZT8udXBkYXRlTm9kZShub2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBub3RlIHdpdGggdGhlIGluZm9ybWF0aW9uIGluIHRoZSBnaXZlbiBTb2hvVHJlZU5vZGUuXG4gICAqXG4gICAqIEBwYXJtIG5vZGUgdGhlIHRyZWUgbm9kZTsgbXVzdCBub3QgYmUgbnVsbC5cbiAgICovXG4gIHB1YmxpYyB1cGRhdGVOb2RlKG5vZGU6IFNvaG9UcmVlTm9kZSk6IHZvaWQge1xuICAgIEFyZ3VtZW50SGVscGVyLmNoZWNrTm90TnVsbCgnbm9kZScsIG5vZGUpO1xuXG4gICAgdGhpcy50cmVlPy51cGRhdGVOb2RlKG5vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGFuZHMgYWxsIHRoZSBsb2FkZWQgdHJlZSBub2Rlcy5cbiAgICpcbiAgICogTm90ZTogdGhpcyBkb2VzIG5vdCBsb2FkIGFkZGl0aW9uYWwgbm9kZXMuXG4gICAqL1xuICBwdWJsaWMgZXhwYW5kQWxsKCkge1xuICAgIGlmICh0aGlzLnRyZWUpIHtcbiAgICAgIHRoaXMudHJlZT8uZXhwYW5kQWxsKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxhcHNlIGFsbCB0aGUgdHJlZSBub2Rlcy5cbiAgICovXG4gIHB1YmxpYyBjb2xsYXBzZUFsbCgpIHtcbiAgICBpZiAodGhpcy50cmVlKSB7XG4gICAgICB0aGlzLnRyZWU/LmNvbGxhcHNlQWxsKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZ2l2ZW4gbm9kZS5cbiAgICovXG4gIHB1YmxpYyByZW1vdmVOb2RlKG5vZGU6IFNvaG9UcmVlTm9kZSkge1xuICAgIGlmICh0aGlzLnRyZWUpIHtcbiAgICAgIHRoaXMudHJlZT8ucmVtb3ZlTm9kZShub2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJlc2VydmVzIGFsbCBub2RlcycgZW5hYmxlbWVudCBzdGF0ZXMgaW4gdGhlIFRyZWUgY29tcG9uZW50XG4gICAqL1xuICBwdWJsaWMgcHJlc2VydmVFbmFibGVtZW50U3RhdGUoKSB7XG4gICAgaWYgKHRoaXMudHJlZSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJlZT8ucHJlc2VydmVFbmFibGVtZW50U3RhdGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZXMgYWxsIG5vZGVzJyBvcmlnaW5hbCBlbmFibGVtZW50IHN0YXRlcyBpbiB0aGUgVHJlZSBjb21wb25lbnRcbiAgICovXG4gIHB1YmxpYyByZXN0b3JlRW5hYmxlbWVudFN0YXRlKCkge1xuICAgIGlmICh0aGlzLnRyZWUpIHtcbiAgICAgIHRoaXMudHJlZT8ucmVzdG9yZUVuYWJsZW1lbnRTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNlbGVjdGVkIG5vdGUgYmFzZWQgaW4gdGhlIGlkIG9mIHRoZSBub2RlLiAgSWYgdGhlIG5vZGVcbiAgICogZG9lcyBub3QgZXhpc3QgYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICovXG4gIHB1YmxpYyBzZWxlY3ROb2RlKGlkOiBzdHJpbmcsIGZvY3VzID0gdHJ1ZSkge1xuICAgIEFyZ3VtZW50SGVscGVyLmNoZWNrTm90RW1wdHkoJ2lkJywgaWQpO1xuXG4gICAgY29uc3QgdHJlZU5vZGU6IHVuZGVmaW5lZCB8IFNvaG9UcmVlTm9kZSA9IHRoaXMudHJlZT8uZmluZEJ5SWQoaWQpO1xuICAgIGlmICh0cmVlTm9kZSAmJiB0cmVlTm9kZS5ub2RlKSB7XG4gICAgICB0aGlzLnRyZWU/LnNlbGVjdE5vZGUodHJlZU5vZGUubm9kZSwgZm9jdXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihgTm9kZSAke2lkfSBkb2VzIG5vdCBleGlzdGApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNlbGVjdGVkIG5vdGUgYmFzZWQgaW4gdGhlIGlkIG9mIHRoZSBub2RlLiAgSWYgdGhlIG5vZGVcbiAgICogZG9lcyBub3QgZXhpc3QgYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICovXG4gIHB1YmxpYyB1blNlbGVjdGVkTm9kZShpZDogc3RyaW5nLCBmb2N1cyA9IGZhbHNlKSB7XG4gICAgQXJndW1lbnRIZWxwZXIuY2hlY2tOb3RFbXB0eSgnaWQnLCBpZCk7XG5cbiAgICBjb25zdCB0cmVlTm9kZTogU29ob1RyZWVOb2RlID0gKHRoaXMudHJlZSBhcyBhbnkpLmZpbmRCeUlkKGlkKTtcbiAgICBpZiAodHJlZU5vZGUgJiYgdHJlZU5vZGUubm9kZSkge1xuICAgICAgKHRoaXMudHJlZSBhcyBhbnkpLnVuU2VsZWN0ZWROb2RlKHRyZWVOb2RlLm5vZGUsIGZvY3VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoYE5vZGUgJHtpZH0gZG9lcyBub3QgZXhpc3RgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2Ygc2VsZWN0ZWQgdHJlZSBub2Rlcywgb3IgYW5cbiAgICogZW1wdHkgYXJyYXkgaWYgdGhlIHRyZWUgaGFzIG5vdCBiZWVuIGluaXRpYWxpc2VkXG4gICAqIHlldC5cbiAgICovXG4gIHB1YmxpYyBnZXRTZWxlY3RlZE5vZGVzKCk6IFNvaG9UcmVlTm9kZVtdIHtcbiAgICBjb25zdCByZXN1bHQ6IFNvaG9UcmVlTm9kZVtdID0gW107XG4gICAgaWYgKHRoaXMudHJlZSkge1xuXG4gICAgICAvLyBJdCB3b3VsZCBiZSBnb29kIGlmIHRoZSB0cmVlIHdpZGdldCBoYWQgYSBtZXRob2QgdGhhdCByZXR1cm5lZFxuICAgICAgLy8gdHJlZSBub2RlcyByYXRoZXIgdGhlbiBhbiBpbnRlcm1lZGlhdGUgd3JhcHBlciwgYnV0IHRvIGNsZWFuIHVwXG4gICAgICAvLyB0aGUgYXBpIHdlIGRpc3Bvc2Ugb2YgdGhlIGV4dHJhIGluZm9ybWF0aW9uIGhlcmUuXG4gICAgICB0aGlzLnRyZWU/LmdldFNlbGVjdGVkTm9kZXMoKS5mb3JFYWNoKFxuICAgICAgICAobikgPT4ge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKG4uZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5vZGUgdG8gdGhlIHRyZWUuXG4gICAqL1xuICBwdWJsaWMgYWRkTm9kZSh0cmVlTm9kZTogU29ob1RyZWVOb2RlLCBsb2NhdGlvbjogYW55ID0gJ2JvdHRvbScsIGlzQmVmb3JlT3JBZnRlciA9ICcnKSB7XG4gICAgQXJndW1lbnRIZWxwZXIuY2hlY2tOb3ROdWxsKCd0cmVlTm9kZScsIHRyZWVOb2RlKTtcblxuICAgIHRoaXMudHJlZT8uYWRkTm9kZSh0cmVlTm9kZSwgbG9jYXRpb24sIGlzQmVmb3JlT3JBZnRlcik7XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgdHJlZSBub2RlIGZvciB0aGUgZ2l2ZW4gaWRlbnRpZmllciAoaWQpLlxuICAgKi9cbiAgcHVibGljIGZpbmRCeUlkKGlkOiBzdHJpbmcpOiBTb2hvVHJlZU5vZGUge1xuICAgIEFyZ3VtZW50SGVscGVyLmNoZWNrTm90RW1wdHkoJ2lkJywgaWQpO1xuXG4gICAgcmV0dXJuICh0aGlzLnRyZWUgYXMgYW55KS5maW5kQnlJZChpZCk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyBvcGVuL2Nsb3NlZCBzdGF0ZSBvZiB0aGUgZ2l2ZW4gdHJlZSBub2RlLlxuICAgKi9cbiAgcHVibGljIHRvZ2dsZU5vZGUobm9kZTogU29ob1RyZWVOb2RlKSB7XG4gICAgQXJndW1lbnRIZWxwZXIuY2hlY2tOb3ROdWxsKCdub2RlJywgbm9kZSk7XG4gICAgQXJndW1lbnRIZWxwZXIuY2hlY2tOb3ROdWxsKCdub2RlLm5vZGUnLCBub2RlLm5vZGUpO1xuXG4gICAgdGhpcy50cmVlPy50b2dnbGVOb2RlKChub2RlLm5vZGUgYXMgYW55KSk7XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEV2ZW50IEhhbmRsZXJzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogSGFuZGxlIGEgcmVxdWVzdCB0byBsb2FkIHRoZSBjaGlsZHJlbiBvZiB0aGUgc3BlY2lmaWVkIG5vZGUuXG4gICAqXG4gICAqIGV2ZW50IC0gdGhlIHRyZWUgZXZlbnQgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggbm9kZSB0byBsb2FkXG4gICAqIHJlc3BvbnNlIC0gZnVuY3Rpb24gdXNlZCB0byByZXR1cm4gdGhlIGNoaWxkcmVuXG4gICAqL1xuICBwcml2YXRlIG9uRGF0YVJlcXVlc3QoZXZlbnQ6IFNvaG9UcmVlRXZlbnQsIHJlc3BvbnNlOiBTb2hvVHJlZVJlc3BvbnNlRnVuY3Rpb24pIHtcbiAgICBjb25zdCBub2RlID0gZXZlbnQuZGF0YTtcblxuICAgIHRoaXMudHJlZVNlcnZpY2UuZ2V0VHJlZU5vZGVzKG5vZGUpXG4gICAgICAuc3Vic2NyaWJlKChjaGlsZHJlbjogU29ob1RyZWVOb2RlW10pID0+IHtcbiAgICAgICAgcmVzcG9uc2UoY2hpbGRyZW4pO1xuICAgICAgfSk7XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gTGlmZWN5Y2xlIEV2ZW50c1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBuZ09uSW5pdCgpIHtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAvLyBXcmFwIHRoZSBcInVub3JkZXJlZCBsaXN0XCIgZWxlbWVudCBpbiBhIGpRdWVyeSBzZWxlY3Rvci5cbiAgICB0aGlzLmpRdWVyeUVsZW1lbnQgPSBqUXVlcnkodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBzb3VyY2UgaXMgc2V0IHdoZW4gYSBzZXJ2aWNlIGlzIGRlZmluZWQuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGF0YXNldCAmJiAhdGhpcy5vcHRpb25zLnNvdXJjZSAmJiB0aGlzLnRyZWVTZXJ2aWNlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuc291cmNlID1cbiAgICAgICAgKGFyZ3M6IFNvaG9UcmVlRXZlbnQsIHJlc3BvbnNlOiBTb2hvVHJlZVJlc3BvbnNlRnVuY3Rpb24pID0+IHRoaXMub25EYXRhUmVxdWVzdChhcmdzLCByZXNwb25zZSk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGlzZSB0aGUgU29obyBjb250cm9sLlxuICAgIHRoaXMualF1ZXJ5RWxlbWVudC50cmVlKHRoaXMub3B0aW9ucyk7XG5cbiAgICAvLyBPbmNlIHRoZSBjb250cm9sIGlzIGluaXRpYWxpc2VkLCBleHRyYWN0IHRoZSBjb250cm9sXG4gICAgLy8gcGx1Zy1pbiBmcm9tIHRoZSBlbGVtZW50LiAgVGhlIGVsZW1lbnQgbmFtZSBpc1xuICAgIC8vIGRlZmluZWQgYnkgdGhlIHBsdWctaW4sIGJ1dCBpbiB0aGlzIGNhc2UgaXQgaXMgJ3RyZWUnLlxuICAgIHRoaXMudHJlZSA9IHRoaXMualF1ZXJ5RWxlbWVudC5kYXRhKCd0cmVlJyk7XG5cbiAgICAvLyBQcmVsb2FkIGZyb20gdGhlIHNlcnZpY2UgaWYgc3BlY2lmaWVkICh1bmxlc3MgZGF0YSBhbHJlYWR5IHByb3ZpZGVkKS5cbiAgICBpZiAodGhpcy50cmVlVHlwZSAhPT0gU29ob1RyZWVDb21wb25lbnQuQ09OVEVOVF9PTkxZICYmICF0aGlzLm9wdGlvbnMuZGF0YXNldCAmJiB0aGlzLnRyZWVTZXJ2aWNlKSB7XG4gICAgICAvLyAuLi4gYm9vdHN0cmFwIHRoZSByb290IG5vZGVzIC4uLlxuICAgICAgdGhpcy50cmVlU2VydmljZS5nZXRSb290VHJlZU5vZGVzKClcbiAgICAgICAgLnN1YnNjcmliZSgoZGF0YXNldDogU29ob1RyZWVOb2RlW10pID0+IHRoaXMuZGF0YXNldCA9IGRhdGFzZXQpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgYW55IGV2ZW50IGhhbmRsZXJzLlxuICAgIHRoaXMualF1ZXJ5RWxlbWVudFxuICAgICAgLm9uKCdjb250ZXh0bWVudScsIChfZTogSlF1ZXJ5LlRyaWdnZXJlZEV2ZW50LCBhcmdzOiBTb2hvVHJlZUV2ZW50KSA9PiB0aGlzLmNvbnRleHRtZW51Py5uZXh0KGFyZ3MpKVxuICAgICAgLm9uKCdzZWxlY3RlZCcsIChfZTogSlF1ZXJ5LlRyaWdnZXJlZEV2ZW50LCBhcmdzOiBTb2hvVHJlZUV2ZW50KSA9PiB0aGlzLnNlbGVjdGVkLm5leHQoYXJncykpXG4gICAgICAub24oJ3Vuc2VsZWN0ZWQnLCAoX2U6IEpRdWVyeS5UcmlnZ2VyZWRFdmVudCwgYXJnczogU29ob1RyZWVFdmVudCkgPT4gdGhpcy51bnNlbGVjdGVkLm5leHQoYXJncykpXG4gICAgICAub24oJ2V4cGFuZGVkJywgKF9lOiBKUXVlcnkuVHJpZ2dlcmVkRXZlbnQsIGFyZ3M6IFNvaG9UcmVlRXZlbnQpID0+IHRoaXMuZXhwYW5kZWQubmV4dChhcmdzKSlcbiAgICAgIC5vbignY29sbGFwc2VkJywgKF9lOiBKUXVlcnkuVHJpZ2dlcmVkRXZlbnQsIGFyZ3M6IFNvaG9UcmVlRXZlbnQpID0+IHRoaXMuY29sbGFwc2VkLm5leHQoYXJncykpXG4gICAgICAub24oJ3NvcnRzdGFydCcsIChfZTogSlF1ZXJ5LlRyaWdnZXJlZEV2ZW50LCBhcmdzOiBTb2hvVHJlZUV2ZW50KSA9PiB0aGlzLnNvcnRzdGFydC5uZXh0KGFyZ3MpKVxuICAgICAgLm9uKCdzb3J0ZW5kJywgKF9lOiBKUXVlcnkuVHJpZ2dlcmVkRXZlbnQsIGFyZ3M6IFNvaG9UcmVlRXZlbnQpID0+IHRoaXMuc29ydGVuZC5uZXh0KGFyZ3MpKVxuICAgICAgLm9uKCdtZW51c2VsZWN0JywgKF9lOiBKUXVlcnkuRXZlbnQsIGFyZ3M6IFNvaG9UcmVlRXZlbnQpID0+IHRoaXMubWVudXNlbGVjdC5uZXh0KGFyZ3MpKVxuICAgICAgLm9uKCdtZW51b3BlbicsIChfZTogSlF1ZXJ5LkV2ZW50LCBhcmdzOiBTb2hvVHJlZUV2ZW50KSA9PiB0aGlzLm1lbnVvcGVuLm5leHQoYXJncykpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMudHJlZSkge1xuICAgICAgdGhpcy50cmVlPy5kZXN0cm95KCk7XG4gICAgICB0aGlzLnRyZWUgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuIl19